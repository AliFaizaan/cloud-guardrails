"""
Generate Terraform for the Azure Policies
"""
import os
import logging
import click
from click_option_group import optgroup, RequiredMutuallyExclusiveOptionGroup
from azure_guardrails import set_log_level
from azure_guardrails.terraform.terraform_no_params import TerraformTemplateNoParams
from azure_guardrails.terraform.terraform_with_params import TerraformTemplateWithParams
from azure_guardrails.iam_definition.azure_policies import AzurePolicies
from azure_guardrails.shared import utils, validate
from azure_guardrails.shared.config import get_default_config, get_config_from_file, Config
from azure_guardrails.shared.parameters_categorized import CategorizedParameters

logger = logging.getLogger(__name__)

supported_services_argument_values = utils.get_service_names()
supported_services_argument_values.append("all")


@click.command(name="generate-terraform", short_help="Generate Terraform to deploy built-in Azure Policies rapidly.")
@optgroup.group("Azure Policy selection", help="")
@optgroup.option(
    "--service",
    "-s",
    type=str,
    default="all",
    help="Services supported by Azure Policy definitions. Defaults to 'all' for all services.",
    callback=validate.click_validate_supported_azure_service,
)
@optgroup.option(
    "--exclude-services",
    "exclude_services",
    type=str,
    help="Exclude specific services (comma-separated) without using a config file.",
    callback=validate.click_validate_comma_separated_excluded_services,
)
@optgroup.option(
    "--enforce",
    "-e",
    "enforcement_mode",
    is_flag=True,
    default=False,
    help="Enforce the security guardrails using 'Deny' mode instead of 'Audit' mode.",
)
@optgroup.group("Configuration", help="")
@optgroup.option(
    "--config",
    "-c",
    "config_file",
    type=click.Path(exists=False),
    required=False,
    help="The config file, generated by the create-config-file command.",
)
@optgroup.option(
    "--parameters",
    "-p",
    "parameters_config_file",
    type=click.Path(exists=False),
    required=False,
    default=None,
    help="The parameters file, generated by the create-parameters-file command.",
)
@optgroup.group("Output file options", help="")
@optgroup.option(
    "--output",
    "-o",
    "output_directory",
    type=click.Path(exists=False, file_okay=False, dir_okay=True),
    default=os.getcwd(),
    help="Specify the *directory* to save the Terraform output. Defaults to current directory.",
)
@optgroup.option(
    "--no-summary",
    "-n",
    is_flag=True,
    default=False,
    help="Do not generate markdown or CSV summary files associated with the Terraform output",
)
@optgroup.group(
    "Parameter Options",
    cls=RequiredMutuallyExclusiveOptionGroup,
    help="",
)
@optgroup.option(
    "--no-params",
    is_flag=True,
    default=False,
    help="Only generate policies that do NOT require parameters",
)
@optgroup.option(
    "--params-optional",
    is_flag=True,
    default=False,
    help="Only generate policies where parameters are OPTIONAL",
)
@optgroup.option(
    "--params-required",
    is_flag=True,
    default=False,
    help="Only generate policies where parameters are REQUIRED",
)
# Mutually exclusive option groups
# https://github.com/click-contrib/click-option-group
# https://stackoverflow.com/questions/37310718/mutually-exclusive-option-groups-in-python-click
@optgroup.group(
    "Policy Scope Targets",
    cls=RequiredMutuallyExclusiveOptionGroup,
    help="",
)
@optgroup.option(
    "--subscription",
    type=str,
    help="The name of a subscription. Supply either this or --management-group",
)
@optgroup.option(
    "--management-group",
    type=str,
    help="The name of a management group. Supply either this or --subscription",
)
@click.option(
    "-v",
    "--verbose",
    "verbosity",
    count=True,
)
def generate_terraform(
    service: str,
    exclude_services: list,
    config_file: str,
    parameters_config_file: str,
    no_summary: bool,
    output_directory: str,
    no_params: bool,
    params_optional: bool,
    params_required: bool,
    subscription: str,
    management_group: str,
    enforcement_mode: bool,
    verbosity: int,
):
    set_log_level(verbosity)

    # Get the config file
    if not config_file:
        logger.info(
            "You did not supply an config file. Consider creating one to exclude different policies. We will use the default one."
        )
        config = get_default_config(exclude_services=exclude_services)
    else:
        config = get_config_from_file(
            config_file=config_file, exclude_services=exclude_services
        )

    # Policy Initiative Category
    category = "Testing"

    if parameters_config_file:
        parameters_config = utils.read_yaml_file(parameters_config_file)
    else:
        parameters_config = None

    terraform = TerraformGuardrails(
        service=service,
        config=config,
        subscription=subscription,
        management_group=management_group,
        parameters_config=parameters_config,
        no_params=no_params,
        params_optional=params_optional,
        params_required=params_required,
        verbosity=verbosity
    )

    terraform_content = terraform.generate_terraform(enforcement_mode=enforcement_mode, category=category)

    output_file = os.path.join(output_directory, terraform.file_name)
    if os.path.exists(output_file):
        logger.info("%s exists. Removing the file and replacing its contents." % output_file)
        os.remove(output_file)
    with open(output_file, "w") as f:
        f.write(terraform_content)

    # Print success message
    terraform.print_success_message(output_file=output_file, output_directory=output_directory, enforcement_mode=enforcement_mode)

    # Markdown and CSV Summary files
    if not no_summary:
        terraform.create_markdown_summary_file()
        terraform.create_csv_summary_file()


class TerraformGuardrails:
    def __init__(
        self,
        service: str,
        config: Config,
        subscription: str,
        management_group: str,
        parameters_config: dict,
        no_params: bool,
        params_optional: bool,
        params_required: bool,
        verbosity: int
    ):
        self.service = service
        self.config = config
        self.azure_policies = self.set_iam_definition()

        if subscription:
            self.subscription = subscription
            self.management_group = ""
        else:
            self.subscription = ""
            self.management_group = management_group

        self.parameters_config = parameters_config
        self.no_params = no_params
        self.params_optional = params_optional
        self.params_required = params_required

        self.audit_only = False

        self.verbosity = verbosity

    def set_iam_definition(self) -> AzurePolicies:
        # Initialize the IAM Definition
        if self.service == "all":
            azure_policies = AzurePolicies(service_names=["all"], config=self.config)
        else:
            azure_policies = AzurePolicies(service_names=[self.service], config=self.config)
        return azure_policies

    @property
    def parameter_requirement_str(self) -> str:
        if self.no_params:
            return "NP"
        elif self.params_optional:
            return "PO"
        elif self.params_required:
            return "PR"

    @property
    def file_name(self) -> str:
        """A file name based on parameter requirements and service name"""
        if self.service == "all":
            service_string = ""
        else:
            service_string = f"_{self.service.lower().strip()}"

        if self.no_params:
            return f"no_params{service_string}.tf"
        elif self.params_optional:
            return f"params_optional{service_string}.tf"
        elif self.params_required:
            return f"params_required{service_string}.tf"

    def generate_terraform(self, enforcement_mode: bool, category: str) -> str:
        # Generate the Terraform file content
        if self.no_params:
            policy_id_pairs = self.azure_policies.get_all_policy_ids_sorted_by_service(
                no_params=True, params_optional=self.params_optional, params_required=self.params_required,
                audit_only=self.audit_only)
            terraform_template = TerraformTemplateNoParams(
                policy_id_pairs=policy_id_pairs,
                subscription_name=self.subscription,
                management_group=self.management_group,
                enforcement_mode=enforcement_mode,
                category=category
            )
        else:
            policy_ids_sorted_by_service = self.azure_policies.get_all_policy_ids_sorted_by_service(
                no_params=self.no_params, params_optional=self.params_optional, params_required=self.params_required,
                audit_only=self.audit_only)

            categorized_parameters = CategorizedParameters(
                azure_policies=self.azure_policies,
                parameters_config=self.parameters_config,
                params_required=self.params_required,
                params_optional=self.params_optional,
                audit_only=self.audit_only
            )

            terraform_template = TerraformTemplateWithParams(
                policy_id_pairs=policy_ids_sorted_by_service,
                parameter_requirement_str=self.parameter_requirement_str,
                categorized_parameters=categorized_parameters,
                subscription_name=self.subscription,
                management_group=self.management_group,
                enforcement_mode=enforcement_mode,
                category=category
            )
        result = terraform_template.rendered()
        return result

    def create_markdown_summary_file(self):
        # Write Markdown summary
        markdown_table = self.azure_policies.markdown_table(
            no_params=self.no_params, params_optional=self.params_optional, params_required=self.params_required
        )
        markdown_file_name = f"{self.parameter_requirement_str}-{self.service}-table.md"
        if os.path.exists(markdown_file_name):
            if self.verbosity >= 1:
                utils.print_grey(f"Removing the previous file: {markdown_file_name}")
            os.remove(markdown_file_name)
        with open(markdown_file_name, "w") as f:
            f.write(markdown_table)

    def create_csv_summary_file(self):
        # Write CSV summary
        csv_file_name = f"{self.parameter_requirement_str}-{self.service}-table.csv"
        self.azure_policies.csv_summary(
            csv_file_name,
            verbosity=self.verbosity,
            no_params=self.no_params,
            params_optional=self.params_optional,
            params_required=self.params_required
        )

    def print_success_message(self, output_file: str, enforcement_mode: bool, output_directory: str):
        utils.print_green("Success!")
        print()
        utils.print_green(f"Generated Terraform file: {os.path.relpath(output_file)}")

        if enforcement_mode:
            enforcement_message = "Enables security policies in *Enforcement mode* (illegal resource changes will be denied)"
        else:
            enforcement_message = "Enables security policies in *Audit mode* (illegal resource changes will be logged)"

        if self.service == "all":
            service_message = "Covers *all* services supported by Azure Policies."
        else:
            service_message = f"Covers *{self.service}* policies."

        if self.no_params:
            params_message = "Targets policies that do *not* require parameters"
        elif self.params_optional:
            params_message = "Targets policies where parameters are *optional* (because the parameters default values)"
        else:
            params_message = "Targets policies where parameters are *required* (because the parameters do not have default values)"

        summary_message = f"""
    The Terraform creates an Azure Policy Initiative that:
    - {enforcement_message}
    - {service_message}
    - {params_message}
    """
        print(summary_message)

        utils.print_blue("To apply these policies with Terraform:")

        if output_directory == os.getcwd():
            directory_string = ""
        else:
            directory_string = f"\n\tcd {os.path.relpath(output_directory)}"

        if self.subscription != "":
            target_string = "subscription"
        else:
            target_string = "management group"

        instructions_message = f"""
    Log in to Azure and set your subscription:
        az login
        az account set --subscription my-subscription

    Then navigate to the directory with your Terraform files and apply the policies:{directory_string}
        terraform init
        terraform plan
        terraform apply -auto-approve

    You will see that the Azure Policy Initiative is now applied to your {target_string}!
        """

        print(instructions_message)

        # TODO: Explain exemptions?
        # TODO: Give summary of the control categories?
